--HiddenDevs Application
--By WillDevLua

--Creating variables to store roblox services. GetService is a method to retrieve different game services.
local DataStoreService = game:GetService("DataStoreService")--Handles saving and loading data
local DataStore = DataStoreService:GetDataStore("DataStore")--Key for saving data to in this game
local Workspace = game:GetService("Workspace")--Handles objects/parts within the game
local TweenService = game:GetService("TweenService")--Handles animations
local ReplicatedStorage = game:GetService("ReplicatedStorage")--Handles server and client communication
local Players = game:GetService("Players")--Handles the players within the game

local TeleportFolder = Workspace:WaitForChild("TeleportParts")
local LobbyPart = TeleportFolder:WaitForChild("Lobby")
local GamePart = TeleportFolder:WaitForChild("Game")
local MapAssets = Workspace:WaitForChild("MapAssets")
local IntermissionTime = 10--Variable holds and integer used in this script to represent time
local RoundTime = 20

local function GetPlayerId(Player) return Player.UserId end--Creates a unique identifier for each player, using the player's id

local function LoadPlayerData(Player)
	local PlayerId = GetPlayerId(Player)--Retrieves the created playerId, using the function GetPlayerId
	local leaderstats = Instance.new("Folder")--Instance.new creates a new object in the game
	leaderstats.Parent = Player--Place the leaderstats folder in the player. This makes it accesable to store data specific to the player
	leaderstats.Name = "leaderstats"
	
	local Points = Instance.new("IntValue")--Creating an IntValue stores integer values
	Points.Parent = leaderstats--Place the points value within the players leaderstats folder
	Points.Name = "Wins"
	Points.Value = 0--Sets the default data value to zero
	
	local success, Data = pcall(function()--Pcall is used to prevent errors in the script
		return DataStore:GetAsync(PlayerId)--If the function succeeds, the data will be returned
	end)
	
	if not success then--Checks if the data retrieval fails
		warn("Data loading error:", Data)--warns the error message
		return--stops the function from running
	elseif Data then--checks if the player already has data
		Points.Value = Data.Points--Update the players value to the saved data
		print(PlayerId.."'s data loaded")
	else
		print("Player has no data")
	end
end

local function SavePlayerData(Player)
	local PlayerId = GetPlayerId(Player)
	local Data = {--Creates a table that will contain the data that needs to be saved
		Points = Player:WaitForChild("leaderstats").Wins.Value--Creates a value to store when the player leaves
	}
	
	local success, errormessage = pcall(function()--if the function fails it will return an error message 
		DataStore:SetAsync(PlayerId, Data)--SetAsync sets the player's values and id to the datastore/key
	end)
	
	if not success then
		warn(errormessage)--if the function has failded warn the errormessage
		return--stops the function from running
	else
		print("Data Saved")
	end
end

Players.PlayerAdded:Connect(LoadPlayerData)
Players.PlayerRemoving:Connect(SavePlayerData)

wait(5)

local function HandleTouch(Touched, LobbyPart)
	local HumanoidRootPart = Touched.Parent:FindFirstChild("HumanoidRootPart")--Gets the players HumanoidRootPart and stores it in a variable
	if not HumanoidRootPart then return end--If the HumanoidRootPart exists
	HumanoidRootPart.CFrame = LobbyPart.CFrame--sets their position, using CFrame (describes a 3D position and orientation), to the lobby's position
end

local function AcidRain()
	local AcidRainFolder = Workspace:WaitForChild("AcidRain")--Checks if the acid rain folder in the workspace exists and creates a variable to it
	if not AcidRainFolder then return end--if the folder doesn't exist, end the function so no further error occur
	for i = 1, RoundTime * 4 do--creates a loop to spawn acid rain like parts every second
		local AcidRain = Instance.new("Part")
		--Configure the parts properties
		AcidRain.Parent = AcidRainFolder
		AcidRain.Transparency = 0.5
		AcidRain.BrickColor = BrickColor.new("Bright blue")
		AcidRain.Material = Enum.Material.Plastic
		AcidRain.Size = Vector3.new(1, 2, 1)--Vector3 is a data type which represents a vector in 3d space
		AcidRain.Position = Vector3.new(math.random(75.5, 124.5), 100, math.random(-24.5, 24.5))--sets the position of the parts to random cordinates within the game zone
		AcidRain.Touched:Connect(function(Touched)--Each acid part listens to see if it's touched using the Touched event
			HandleTouch(Touched, LobbyPart)--fires the HandleTouch function which sends the player back to the lobby
		end)
		
		task.delay(5, function() AcidRain:Destroy() end)--After 5 seconds it passes a function that uses the Destory() function to remove the part
		task.wait(0.25)--add a cooldown of 0.25 to prevent lag
	end
end

local function Lava()
	local LavaFolder = Workspace:WaitForChild("Lava")--Checks if the lava folder is in the workspace and creates a variable to it
	if not LavaFolder then return end--if the lava folder doesn't exist then end the function
	local Lava = Instance.new("Part")--instance.new creates a new object into the game, in this case a part
	Lava.Parent = LavaFolder--puts the part into the folder, located within the workspace
	Lava.Name = "Lava"
	Lava.Anchored = true
	Lava.BrickColor = BrickColor.new("Bright red")
	Lava.Material = Enum.Material.Neon
	Lava.Size = Vector3.new(49.9, 1.99, 49.9)--Vector3 is a data type which represents a vector in 3d space
	Lava.Position = Vector3.new(100, 0, 0)
	
	local LavaTweenInfo = TweenInfo.new(
		15,--Sets the tween to last for 15 seconds
		Enum.EasingStyle.Linear,--enum is used to chose a style for which the tween will run, in our case it will be linear/normal
		Enum.EasingDirection.In,
		0,--ensures that the tween doesn't repeat
		false--ensures that the tween doesn't reverse
	)
	
	local LavaTweenGoal = {--creates a table for the desired properties that the tween will result in
		Size = Vector3.new(Lava.Size.X, 10, Lava.Size.Z),--vector3 is used to configure the part to grow up to 10 studs on the Y axis
		Position = Lava.Position + Vector3.new(0, (10 - Lava.Size.Y) / 2, 0)
	}
	local LavaTween = TweenService:Create(Lava, LavaTweenInfo, LavaTweenGoal)--creates a variable for the tween ready to be played
	task.wait(RoundTime / 5)--waits one fith of the round time to give players to prepare, using the task.wait function to avoid bugs and reduce lag
	LavaTween:Play()--Plays the lava rising tween
	
	Lava.Touched:Connect(function(Touched)--Uses the touched event to connect to a function
		HandleTouch(Touched, LobbyPart)--fires the HandleTouch function which sends the player back to the lobby
	end)
	
	task.wait(RoundTime)--waits 20 seconds before continuing the code, using task.wait which is used to reduce lag and waits for the server
	if Lava then Lava:Destroy() end--Removes the lava object from the game, using the Destory() function
end

local function Tsunami()
	local Tsunami = ReplicatedStorage:WaitForChild("TsunamiPart"):Clone()--Checks if the tsunami is there and links it to a variable
	if not Tsunami then return end--if the tsunami folder doesn't exist it end the function
	Tsunami.Parent = Workspace:WaitForChild("Tsunami")--put's the tsunami into the workspace by parenting it to a folder
	Tsunami.Transparency = 0
	
	--Creating the tween style
	local TsunamiTweenInfo = TweenInfo.new(
		20,--makes the tweek ;ast 20 seconds
		Enum.EasingStyle.Linear,--choses the way in which the tsunami will tween
		Enum.EasingDirection.In,
		0,--ensures that the tween doesn't repeat
		false--ensures that the tween doesn't reverse
	)
	
	local TsunamiGoal = {--creates a table to contain the end goal of the tween
		CFrame = Tsunami.CFrame - Vector3.new(0, 0, 100)--the tsunami will travel 100 studs on the Z axis
	}
	local TsunamiTween = TweenService:Create(Tsunami, TsunamiTweenInfo, TsunamiGoal)--creates a tween to later be called
	Tsunami.Anchored = true
	TsunamiTween:Play()--plays the tsunamitween
	
	Tsunami.Touched:Connect(function(Touched)--Uses the touched event to connect to a function
		HandleTouch(Touched, LobbyPart)--fires the HandleTouch function which sends the player back to the lobby
	end)
	
	task.wait(RoundTime)--waits 20 seconds before continuing the code, using task.wait which is used to reduce lag and waits for the server
	if Tsunami then Tsunami:Destroy() end--Removes the tsunami object from the game, using the Destory() function
end

local function Flood()
	local WaterFolder = Workspace:WaitForChild("Water")--Creates a variable for the waterfolder
	if not WaterFolder then return end--if the water folder doesn't exist then end the function
	local Flood = Instance.new("Part")--Isntance.new spawns a new object into the game, in our case a part
	--copnfigure the part properties
	Flood.Parent = WaterFolder
	Flood.Name = "Water"
	Flood.Anchored = true
	Flood.Transparency = 0.5
	Flood.CanCollide = false
	Flood.BrickColor = BrickColor.new("Cyan")
	Flood.Size = Vector3.new(49.9, 1.99, 49.9)--Vector3 is a data type which represents a vector in 3d space
	Flood.Position = Vector3.new(100, 0, 0)

	local FloodTweenInfo = TweenInfo.new(
		15,--makes the tween last 15 seconds
		Enum.EasingStyle.Linear,--enum is used to retreve a specific easing style from the roblox api
		Enum.EasingDirection.In,
		0,--ensures the tween doesn't repeat
		false--ensures the tween doesn't repeat
	)

	local FloodTweenGoal = {--creates a table to list the changes that will happen to the object
		Size = Vector3.new(Flood.Size.X, 10, Flood.Size.Z),--Will increase the Y axis by 10 studs
		Position = Flood.Position + Vector3.new(0, (10 - Flood.Size.Y) / 2, 0)--counteracts the effect, where the y axis increases on the bottom and top, by moving its position accordingly
	}
	local FloodTween = TweenService:Create(Flood, FloodTweenInfo, FloodTweenGoal)--creates a variable ready to store a tween/animation
	task.wait(RoundTime / 5)--waits one fith of the time in order to give the player some preperation time
	FloodTween:Play()--fires the tween(water rising)

	Flood.Touched:Connect(function(Touched)--Uses the touched event to connect to a function
		HandleTouch(Touched, LobbyPart)--fires the HandleTouch function which sends the player back to the lobby
	end)

	task.wait(RoundTime)
	if Flood then Flood:Destroy() end
end

local Disasters = {--Creates a table to list all the disasters
	["Acid Rain"] = AcidRain,--each disaster is paired to it's corresponding function
	["Lava"] = Lava,
	["Tsunami"] = Tsunami,
	["Flood"] = Flood
}
local TimeEvent = ReplicatedStorage:WaitForChild("Time")--Declare some event variables
local WinEvent = ReplicatedStorage:WaitForChild("Win")
local Round

while true do--creates a loop that runs indefinately
	local DisasterKeys = {}--creates a table of the disaster names
	for Key in pairs(Disasters) do--loops through the disasters table
		table.insert(DisasterKeys, Key)--adds each disaster to the disasterkeys table
	end

	local RandomDisaster = DisasterKeys[math.random(1, #DisasterKeys)]--picks a random index and the corresponding disaster function is called
	
	Round = "Intermission"--updates the variable to the current round(intermission)
	TimeEvent:FireAllClients(IntermissionTime, Round)--fires the event to the client to update guis
	task.wait(IntermissionTime)--counts down from the intermissiontime(10) down to 1 before resuming the script
	
	for i, v in pairs(Players:GetPlayers()) do--loops through all the players registered in the game
		v.Character:WaitForChild("HumanoidRootPart").CFrame = GamePart.CFrame--sets their position, using CFrame (describes a 3D position and orientation), to the gamepart's position
	end
	
	print(RandomDisaster)
	task.spawn(Disasters[RandomDisaster])--task.spawn is used to run the disaster function in a sperate thread so that the game continues playing
	
	Round = RandomDisaster--update the round vaiable to the chosen disaster
	TimeEvent:FireAllClients(RoundTime, Round)--fires the event to the client to update guis
	task.wait(RoundTime)--counts down from the roundtime(20) down to 1 before resuming the script
	
	local Winners = {}--creates a table to register the players that have won
	local WinZone = Instance.new("Part")--the win part is created, using instance.new, to register the players still in the playing zone
	WinZone.Parent = Workspace
	WinZone.Transparency = 1--makes the part invisible
	WinZone.CanCollide = false
	WinZone.Size = Vector3.new(50, 23, 50)--the size of the part is created, using vector3.new, to match the game area 
	WinZone.Position = Vector3.new(100, 12.5, 0)
	WinZone.Anchored = true
	WinZone.Touched:Connect(function(Touched)--runs the function when the event, touched, is called
		local Player = Players:GetPlayerFromCharacter(Touched.Parent)--finds the player through the parent of the part that touched the part
		local leaderstats = Player:WaitForChild("leaderstats")--creates a variable for the players leaderstats found within them
		if Player and leaderstats and leaderstats:FindFirstChild("Wins") and not Winners[Player.UserId] then--if the player exists and is not already in the win table it runs the following code
			Winners[Player.UserId] = true--adds the player to the winner table
			leaderstats.Wins.Value += 1--Increases the players wins by one
			WinEvent:FireClient(Player)
		end
	end)
	task.wait(2.5)
	if WinZone then WinZone:Destroy() end--removes the winpart from the game, using the destroy function

	for i, v in pairs(Players:GetPlayers()) do--loops through all the players registered in the game
		v.Character:WaitForChild("HumanoidRootPart").CFrame = LobbyPart.CFrame--sets their position, using CFrame (describes a 3D position and orientation), to the lobbys position
	end
end
